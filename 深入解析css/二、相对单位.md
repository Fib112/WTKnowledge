### 一、em和rem

#### 1.1 使用em 定义字号 

谈到font-size 属性时，em 表现得不太一样。之前提到过，当前元素的字号决定了em。
但是，如果声明font-size: 1.2em，会发生什么呢？一个字号当然不能等于自己的1.2 倍。实
际上，这个font-size 是根据继承的字号来计算的。

如：

```html
body { 
  font-size: 16px; 
} 
 
.slogan {  
  font-size: 1.2em; 
} 

<body> 
  We love coffee 
  <p class="slogan">We love coffee</p>   
</body>
```

slogan 的指定字号是1.2em。为了得到计算的像素值，需要参考继承的字号，即16px。因为
16×1.2 = 19.2，所以计算值为19.2px。

#### 1.2 em 同时用于字号和其他属性 

现在你已经用 em 定义了字号（基于继承的字号），而且也用 em 定义了其他属性，比如
padding 和border-radius（基于当前元素的字号）。em 的复杂之处在于同时用它指定一个元
素的字号和其他属性。这时，浏览器必须先计算字号，然后使用这个计算值去算出其余的属性值。
这两类属性可以拥有一样的声明值，但是计算值不一样。 
如：

```css
body { 
  font-size: 16px; 
} 
 
.slogan { 
  font-size: 1.2em;  
  padding: 1.2em;   
  background-color: #ccc; 
}
```

在这个例子里，padding 的声明值为1.2em，乘以19.2px（当前元素的字号），得到计算值
为23.04px。尽管font-size 和padding 的声明值相同，计算值却不一样

#### 1.3 字体缩小的问题

当用em 来指定多重嵌套的元素的字号时，就会产生意外的结果。为了算出每个元素的准确
值，就需要知道继承的字号，如果这个值是在父元素上用em 定义的，就需要知道父元素的继承
值，以此类推，就会沿着DOM 树一直往上查找。 当使用em 给列表元素定义字号并且多级嵌套时，这个问题就显现出来了。

当列表多级嵌套并且给每一级使用em 定义字号时，就会发生文字缩小的现象：

```css
body { 
  font-size: 16px; 
} 
 
ul { 
  font-size: .8em; 
} 

<ul>  
  <li>Top level 
    <ul> 
      <li>Second level 
        <ul>  
          <li>Third level 
            <ul>  
              <li>Fourth level 
                <ul> 
                  <li>Fifth level</li> 
                </ul> 
              </li> 
            </ul> 
          </li> 
        </ul> 
      </li> 
    </ul> 
  </li> 
</ul>
```

每个列表元素的字号等于0.8 乘以其父元素的字号。算出来第一级列表的字号为12.8px，第
二级缩小到10.24px（12.8px × 0.8），第三级缩小到8.192px，以此类推。同理，如果指定一个大于 1em 的字号，文字会逐渐增大。

![](https://gitee.com/Topcvan/img-storage/raw/master/css/%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E6%96%87%E5%AD%97%E7%BC%A9%E5%B0%8F.png)

#### 1.4 使用rem设置字号

当浏览器解析HTML 文档时，会在内存里将页面的所有元素表示为DOM（文档对象模型）。
它是一个树结构，其中每个元素都由一个节点表示。`<html>`元素是顶级（根）节点。它下面是
子节点，`<head>`和`<body>`。再下面是逐级嵌套的后代节点。 

在文档中，根节点是所有其他元素的祖先节点。根节点有一个伪类选择器（:root），可以
用来选中它自己。这等价于类型选择器html，但是:root 的优先级相当于一个类名，而不是一
个标签。

先指定根元素的字号，然后用rem 定义无序列表的相对字号，就可以解决嵌套列表字体缩小的问题：

```css
:root {
    font-size: 1em; // 根据默认字体大小16px来计算
}

ul {
    font-size: .8rem;
}
```

在这个例子里，根元素的字号为浏览器默认的字号16px（根元素上的em 是相对于浏览器默
认值的）。无序列表的字号设置为 0.8rem，计算值为 12.8px。因为相对根元素，所以所有字号始终一致，就算是嵌套列表也一样

与 em 相比，rem 降低了复杂性。实际上，rem 结合了 px 和 em 的优点，既保留了相对单位
的优势，又简单易用。那是不是应该全用rem，抛弃其他选择呢？答案是否定的。 
在CSS 里，答案通常是“看情况”。rem 只是工具包中的一种工具。掌握CSS 很重要的一点是学会在适当的场景使用适当的工具。一般会用rem 设置字号，用px 设置边框，用em 设置
其他大部分属性，尤其是内边距、外边距和圆角（不过有时用百分比设置容器宽度）。 
这样字号是可预测的，同时还能在其他因素改变元素字号时，借助em 缩放内外边距。用px
定义边框也很好用，尤其是想要一个好看又精致的线时。 

拿不准的时候，用rem 设置字号，用px 设置边框，用em 设置其他大部分属性。 

### 二、停止像素思维

#### 2.1 设置一个合理的默认字号

如果希望默认字号为14px，那么不要将默认字体设置为10px 然后再覆盖一遍，而应该直
接将根元素字号设置为想要的值。将想要的值除以继承值（在这种情况下为浏览器默认值）是
14/16，等于0.875

```css
:root {  
  font-size: 0.875em;  
}
```

现在你已经给网页设置了想要的字号，不用在其他地方再指定一遍了。只需要相对它去修
改其他元素（比如标题）的字号

#### 2.2 构造响应式面板

更进一步地说，我们甚至可以根据屏幕尺寸，用媒体查询改变根元素的字号。这样就能够基
于不同用户的屏幕尺寸，渲染出不同大小的面板

如：

```css
:root {  
  font-size: 0.75em; /* 作用到所有的屏幕，但是在大屏上会被覆盖 */
} 

@media (min-width: 800px) {  
  :root { 
    font-size: 0.875em; /* 仅作用到宽度800px及其以上的屏幕，覆盖之前的值*/
  } 
} 
 
@media (min-width: 1200px) {  
  :root { 
    font-size: 1em; /* 仅作用到宽度1200px及其以上的屏幕，覆盖之前的值*/
  } 
} 
```

#### 2.3 缩放单个组件 

有时，需要让同一个组件在页面的某些部分显示不同的大小，可以用`em`来单独缩放一个
组件。拿之前的面板举例。首先给面板加上一个large 类：`<div class="panel large">`。

下面稍微改一下定义面板字号的方式。我们仍然使用相对单位，但是需要改变它相对的对象。
首先，给每个面板添加父元素声明font-size: 1rem，这样无论面板位于页面何处，都有一个
可预测的字号。 其次，改用em 而不是用rem，重新定义标题的字号，使其相对于刚刚在1rem 时创建的父元素的字号

```css
.panel { 
  font-size: 1rem;  
  padding: 1em; 
  border: 1px solid #999; 
  border-radius: 0.5em; 
} 
 
.panel > h2 { 
  margin-top: 0; 
  font-size: 0.8em;  
  font-weight: bold; 
  text-transform: uppercase; 
}
```

次修改并不会影响面板的样式，但是它为创建更大的面板做好了准备：只需要加一行CSS代码，即覆盖父元素的 1rem。因为组件内所有的大小都是相对于父元素的字号，所以覆盖后，整个面板的大小都会改变。

```css
.panel.large {  
  font-size: 1.2rem; 
} 
```

现在对普通面板使用class="panel"，对大面板使用class="panel large"。同理，可以设置一个更小的字号来定义一个小面板。如果面板是一个更复杂的组件，有多个字号和内边距，仍然只需要一个声明就能缩放它，只要内部的样式都使用em 定义即可。

### 三、视口相对单位

前面介绍的em 和rem 都是相对于font-size 定义的，但CSS 里不止有这一种相对单位。
还有相对于浏览器视口定义长度的视口的相对单位

- vh：视口高度的1/100。 
- vw：视口宽度的1/100。 
- vmin：视口宽、高中较小的一方的1/100（IE9 中叫vm，而不是vmin）。  
- vmax：视口宽、高中较大的一方的1/100

#### 3.1 使用vw定义字号

相对视口单位有一个不起眼的用途，就是设置字号，但它比用vh 和vw 设置元素的宽和高还要实用。 如果给一个元素加上font-size: 2vw 会发生什么？

在一个1200px 的桌面显示器上，计算值为24px（1200 的2%）。在一个768px 宽的平板上，计算值约为15px（768 的2%）。 这样做的好处在于元素能够在这两种大小之间平滑地过渡，这意味着不会在某个断点突然改变。当视口大小改变时，元素会逐渐过渡。

不幸的是，24px 在大屏上来说太大了。更糟糕的是，在iPhone 6 上会缩小到只有7.5px。如果能够保留这种缩放的能力，但是让极端情况缓和一些就更棒了。CSS 的calc()函数可以提供帮助

#### 3.2 使用calc()定义字号

calc()函数内可以对两个及其以上的值进行基本运算。当要结合不同单位的值时，calc()特别实用。它支持的运算包括：加（+）、减（ −）、乘（×）、除（ ÷）。加号和减号两边必须有空白。

用 calc()结合 em 和 vw 两种单位。删除之前样式表的基础字号（以及相关的媒体查询），换成如下代码：

```css
:root { 
  font-size: calc(0.5em + 1vw); 
}
```

现在打开网页，慢慢缩放浏览器，字体会平滑地缩放。0.5em 保证了最小字号，1vw 则确保
了字体会随着视口缩放。这段代码保证基础字号从iPhone 6 里的11.75px 一直过渡到1200px 的浏览器窗口里的20px。可以按照自己的喜好调整这个值。 

我们不用媒体查询就实现了大部分的响应式策略。省掉三四个硬编码的断点，网页上的内容
也能根据视口流畅地缩放。

### 四、无单位的数值和行高

有些属性允许无单位的值（即一个不指定单位的数）。支持这种值的属性包括line-height、
z-index、font-weight（700 等于bold，400 等于normal，等等）。任何长度单位（如px、em、rem）都可以用无单位的值0，因为这些情况下单位不影响计算值，即0px、0%、0em 均相等

line-height 属性比较特殊，它的值既可以有单位也可以无单位。通常我们应该使用无单位的数值，因为它们继承的方式不一样。

用无单位的数值定义的行高：

```css
body { 
  line-height: 1.2;  /* 后代元素继承了无单位的值*/
} 
 
.about-us { 
  font-size: 2em; 
}
```

这个段落继承了行高1.2。因为段落字号是32px（2em  ×  16px，浏览器默认字号 ），所以此时行高的计算值为38.4px（32px×1.2）。每行文字之间都会有一个合理的间距。

如果用有单位的值定义行高，可能会产生意想不到的结果：

```css
body { 
  line-height: 1.2em;  // 后代元素继承了计算值（19.2px）
} 
 
.about-us { 
  font-size: 2em;  // 计算值为32px
} 
```

后代元素继承了计算值（19.2px），每行文字会重叠。

这些结果源于继承的一个怪异特性：当一个元素的值定义为长度（px、em、rem，等等）时，
子元素会继承它的计算值。当使用em 等单位定义行高时，它们的值是计算值，传递到了任何继承子元素上。如果子元素有不同的字号，并且继承了line-height 属性，就会造成意想不到的
结果，比如文字重叠。

长度——一种用于测量距离的CSS 值的正式称谓。它由一个数值和一个单位组成，比如5px。长度有两种类型：绝对长度和相对长度。百分比类似于长度，但是严格来讲，它不是长度。

使用无单位的数值时，继承的是声明值，即在每个继承子元素上会重新算它的计算值。这样
得到的结果几乎总是我们想要的。我们可以用一个无单位的数值给 body 设置行高，之后就不用修改了，除非有些地方想要不一样的行高

### 五、自定义属性

2015 年，一个期盼已久的 CSS 规范作为候选推荐标准问世了，叫作层叠变量的自定义属性（Custom Properties for Cascading Variables）。这个规范给CSS 引进了变量的概念，开启了一种全新的基于上下文的动态样式。你可以声明一个变量，为它赋一个值，然后在样式表的其他地方引用这个值。这样不仅能减少样式表中的重复，而且还有其他好处。

定义一个自定义属性，只需要像其他 CSS 属性那样声明即可：

```css
:root { 
  --main-font: Helvetica, Arial, sans-serif; 
} 
```

这个代码清单定义了一个名叫--main-font 的变量。将其值设置为一些常见的sans-serif 字
体。变量名前面必须有两个连字符（--），用来跟CSS 属性区分，剩下的部分可以随意命名。 
变量必须在一个声明块内声明。这里使用了:root 选择器，因此该变量可以在整个网页使用。

变量声明本身什么也没做，我们使用时才能看到效果。调用函数 var()就能使用该变量。利用该函数引用前面定义的变量--main-font。

```css
:root { 
  --main-font: Helvetica, Arial, sans-serif; 
} 
 
p {  
  font-family: var(--main-font); 
}
```

var()函数接受第二个参数，它指定了备用值。如果第一个参数指定的变量未定义，那么就
会使用第二个值。

如果 var()函数算出来的是一个非法值，对应的属性就会设置为其初始值。比如，如果在padding: var(--brand-color)中的变量算出来是一个颜色，它就是一个非法的内边距值。这种情况下，内边距会设置为0。

#### 5.1 动态改变自定义属性

在前面的示例中，自定义属性只不过为减少重复代码提供了一种便捷方式，但是它真正的意
义在于，自定义属性的声明能够层叠和继承：可以在多个选择器中定义相同的变量，这个变量在网页的不同地方有不同的值。 

例如，可以定义一个变量为黑色，然后在某个容器中重新将其定义为白色。那么基于该变量
的任何样式，在容器外部会动态解析为黑色，在容器内部会动态解析为白色。

#### 5.2 使用JavaScript 改变自定义属性

还可以使用 JavaScript 在浏览器中实时访问和修改自定义属性，如：

访问自定义属性：

```javascript
<script type="text/javascript"> 
  var rootElement = document.documentElement; 
  var styles = getComputedStyle(rootElement);   
  var mainColor = styles.getPropertyValue('--main-bg');  
  console.log(String(mainColor).trim()); 
</script> 
```

使用JavaScript 设置一个自定义属性：

```css
var rootElement = document.documentElement;   
rootElement.style.setProperty('--main-bg', '#cdf');  
```

