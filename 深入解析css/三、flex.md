### 一、FlexBox的原则

给元素添加 display: flex，该元素变成了一个弹性容器（flex container），它的直接子元素变成了弹性子元素（flex item）。弹性子元素默认是在同一行按照从左到右的顺序并排排列。弹性容器像块元素一样填满可用宽度，但是弹性子元素不一定填满其弹性容器的宽度。弹性子元素高度相等，该高度由它们的内容决定。Flexbox 允许使用margin: auto 来填充弹性子元素之间的可用空间。

还可以用 display: inline-flex。它创建了一个弹性容器，行为类似于inline-block 元素。它会跟其他行内元素一起流式排列，但不会自动增长到100%的宽度。内部的弹性子元素跟使用display: flex 创建的Flexbox 里的弹性子元素行为一样。

### 二、弹性子盒子的大小

flex 属性控制弹性子元素在主轴方向上的大小（在这里指的元素的宽度）。flex 属性是三个不同大小属性的简写：flex-grow、flex-shrink 和 flex-basis。如果只提供了flex-grow 的值，剩下的两个属性是默认值（分别是1 和0%），因此flex: 2 等价于flex: 2 1 0%。通常首选简写属性，但也可以分别声明三个属性。 

与大部分简写属性不一样，如果在 flex 中忽略某个子属性，那么子属性的值并不会被置为初始值。相反，如果某个子属性被省略，那么flex 简写属性会给出有用的默认值：flex-grow 为1、flex-shrink 为1、flex-basis 为0%。这些默认值正是大多数情况下所需要的值。

#### 2.1 使用flex-basis属性

flex-basis 定义了元素大小的基准值，即一个初始的“主尺寸”。flex-basis 属性可以设置为任意的width 值，包括px、em、百分比。它的初始值是auto，此时浏览器会检查元素是否设置了width 属性值。如果有，则使用width  的值作为flex-basis 的值；如果没有，则用元素内容自身的大小。如果flex-basis 的值不是auto，width 属性会被忽略。

每个弹性子元素的初始主尺寸确定后，它们可能需要在主轴方向扩大或者缩小来适应（或者
填充）弹性容器的大小。这时候就需要flex-grow 和flex-shrink 来决定缩放的规则

#### 2.2 使用flex-grow属性 

每个弹性子元素的flex-basis 值计算出来后，它们（加上子元素之间的外边距）加起来会
占据一定的宽度。加起来的宽度不一定正好填满弹性容器的宽度，可能会有留白。

多出来的留白（或剩余宽度）会按照flex-grow（增长因子）的值分配给每个弹性子元素，
flex-grow 的值为非负整数。如果一个弹性子元素的flex-grow 值为0，那么它的宽度不会超
过flex-basis 的值；如果某个弹性子元素的增长因子非0，那么这些元素会增长到所有的剩余
空间被分配完，也就意味着弹性子元素会填满容器的宽度。

flex-grow 的值越大，元素的“权重”越高，也就会占据更大的剩余宽度。一个flex-grow: 
2 的子元素增长的宽度为flex-grow: 1 的子元素的两倍

#### 2.3 使用flex-shrink属性 

flex-shrink 属性与flex-grow 遵循相似的原则。计算出弹性子元素的初始主尺寸后，它们的累加值可能会超出弹性容器的可用宽度。如果不用flex-shrink，就会导致溢出。

每个子元素的 flex-shrink 值代表了它是否应该收缩以防止溢出。如果某个子元素为
flex-shrink: 0，则不会收缩；如果值大于0，则会收缩至不再溢出。按照  flex-shrink 值
的比例，值越大的元素收缩得越多。 

用flex-shrink 也能实现上述页面中两列的宽度。首先将两列的flex-basis 指定为理想的比例（66.67%和33.33%）。它们的宽度之和加上1.5em 的间隔就会比容器宽度多出1.5em。然后将两列的flex-shrink 设置为1，这样就会从每列的宽度减掉0.75em，于是容器就能容纳两列了。

### 三、弹性方向

Flexbox 的另一个重要功能是能够切换主副轴方向，用弹性容器的flex-direction 属性控制。如前面的例子所示，它的初始值（row）控制子元素按从左到右的方向排列；指定flex-direction: column 能控制弹性子元素沿垂直方向排列（从上到下）。Flexbox 还支持row-reverse 让元素从右到左排列，column-reverse 让元素从下到上排列。

指定flex-direction: column后，内部的弹性盒子的弹性方向为column，因此主轴发生了旋转，现在变成了从上到下（副轴变成了从左到右）。也就是对于弹性子元素而言，flex-basis、flex-grow 和 flex-shrink现在作用于元素的高度而不是宽度。由于指定了 flex: 1，因此在必要的时候子元素的高度会扩展到填满容器。无论哪边更高，主板块的底部和右边第二个小板块的底部都会对齐。

 水平弹性盒子的大部分概念同样适用于垂直的弹性盒子（column 或column-reverse），但是有一点不同：在 CSS 中处理高度的方式与处理宽度的方式在本质上不一样。弹性容器会占据100%的可用宽度，而高度则由自身的内容来决定。即使改变主轴方向，也不会影响这一本质。 弹性容器的高度由弹性子元素决定，它们会正好填满容器。在垂直的弹性盒子里，子元素的flex-grow 和 flex-shrink 不会起作用，除非有“外力”强行改变弹性容器的高度。

### 四、其他属性

#### 4.1 flex-wrap 属性 

flex-wrap 属性允许弹性子元素换到新的一行或多行显示。它可以设置为 nowrap（初始值）、wrap 或者wrap-reverse。启用换行后，子元素不再根据flex-shrink 值收缩，任何超过弹性容器的子元素都会换行显示。 如果弹性方向是column 或column-reverse，那么 flex-wrap 会允许弹性子元素换到新的一列显示，不过这只在限制了容器高度的情况下才会发生，否则容器会扩展高度以包含全部弹性子元素

#### 4.2 justify-content 属性 

当子元素未填满容器时，justify-content 属性控制子元素沿主轴方向的间距。间距是在元素的外边距之后进行计算的，而且flex-grow 的值要考虑进来。也就是说，如果任意子元素的 flex-grow 的值不为 0，或者任意子元素在主轴方向的外边距值为 auto，justify-content 就失效了

#### 4.3 align-items 属性 

justify-content 控制子元素在主轴方向的对齐方式，align-items 则控制子元素在副轴方向的对齐方式。align-items 的初始值为stretch，在水平排列的情况下让所有子元素填充容器的高度，在垂直排列的情况下让子元素填充容器的宽度，因此它能实现等高列。 其他的值让弹性子元素可以保留自身的大小，而不是填充容器的大小。（类似的概念有vertical-align 属性。） 

### 五、整页布局

Flexbox 的一个有趣之处在于如何基于弹性子元素的数量和其中的内容量（及大小）来计算容器的大小。因为如果网页很大，或者加载很慢时可能会产生奇怪的行为。 当浏览器加载内容时，它渐进渲染到了屏幕，即使此时网页的剩余内容还在加载。

假设有一个使用弹性盒子（flex-direction: row）实现的三列布局。如果其中两列的内容加载了，浏览器可能会在加载完第三列之前就渲染这两列。然后等到剩余内容加载完，浏览器会重新计算每个弹性子元素的大小，重新渲染网页。用户会短暂地看到两列布局，然后列的大小改变（可能改变特别大），并出现第三列。 

Jake  Archibald 是 Google  Chrome 的技术推广工程师，他写过一篇文章 Don’t  use  flexbox  for  overall  page  layout 讨论这个问题  。你可以在这篇文章里看到前面所说的情况。他给出的一个建议是对整页布局的时候使用网格布局

说明 ：只有一行多列的布局才会产生这个问题。如果主页面布局采用的是一列多行（flex-direction: column），就不会出现以上问题。